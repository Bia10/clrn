Обмен хостами
Хост 1 при обнаружении хоста 2 подписывается на эвенты изменения таблиц hosts и host_map, т.о. заполняя соответствующие таблицы у себя и информируя другие хосты, если произошли изменения.
Т.е. хост1 отправляет новый хост на хост2, хост2 отправляет его всем хостам, т.е. обратно первому(тот его игнорит т.к. уже есть) и остальным известным.
Т.о. получается что известные хосты распространяются волной.

Обмен файлами
1. Джоб GET_FILES_INFO - отправляем на удаленный хост в случае если нам не известен список файлов этого хоста, получаем список файлов
	- если файл присутсвтует полностью в таблице files установден флаг complete
	- если файл не полностью получаем вместе со списком файлов доступные чанки
2. Джоб SET_FILES_INFO - отправляем на удаленный хост в случае если наши файлы изменились, отправляем не чаще чем интервал в настройках(секунда например)
	- по аналогии с GET_FILES_INFO
3. Джоб GET_FILE_DATA - отправляем на удаленный хост для получения контента файла
	- отправляем id файла и id чанка
	- получаем данные
4. Джобы анализируются SyncManager'ом:
	- появились локальные изменения - шлем всем хостам SET_FILES_INFO
	- добавился хост о файлах которого мы не знаем - шлем GET_FILES_INFO
	- пришел запрос SET_FILES_INFO - шлем запросы GET_FILE_DATA хостам у которых есть нужные части файла
	- агрегируем данные по хостам, распределяем запросы, шлем максимальному кол-ву хостов
	- получаем данные по файлу, заносим в таблицу file_chunks id чанка и его индекс в файле свопа, если полученны все чанки - чистим таблицу file_chunks
	
Подумать что делать в ситуациях конфликтов, т.е. на одно хосте изменили файл, тут же с него начал обновляться второй хост, потом на втором хосте поменяли этот же файл.
думаю стоит отслеживать это хрень, скачиваемый файл будет в свопе, как только локальный файл изменили льеняем скачку и гворим что есть версия новее.
тут стоит выдать предупрежждение, но этот вопрос уходит в version control

+1. Реализовать разделение логгера для различных модулей.
	+ хранить вектор указателей на стримы
	+ передавать в каждый метод записи Id модуля
2. Реализовать механизм коннекта
	- CConnectionEstablisher мониторит евенты активности хостов, подписывается на евенты активных хостов: host_map_event.
	- отслеживает ситуации когда очередной хост стал недоступен или пришел евент host_map о доступности с другого хоста:
		- хосту А не доступен хост B, но доступен хост C, с хоста C приходит евент о том, что хост B доступен для хоста C. 
		- хосту А доступен хост B и C, хост B становится недоступен, при этом остается доступным для хоста C.
	- А отслеживает описанные выше евенты, запускает джоб GET_CONNECTION на хост С
	- хост С, получивший джоб GET_CONNECTION создает запись в таблице host_map с данными запрашиваемого соединения(статус 2, NAT ip:port), при этом ответный пакет не посылается
	- об этом с помощью евентов информируются хосты А и B
		- хост А перестает посылку GET_CONNECTION, ждет евента о готовности хоста B
		- хост B увидев что с ним хочет соединиться хост A(по евенту от С) посылает джоб GET_CONNECTION на хост С(или не посылает, если уже сделал это одновременно с хостом А)
	- в итоге хосты А и B получают евент с хоста C о намерении подключиться друг к другу(запись из host_map).
	- как только получены ендпоинты они устанавливаются для каждого хоста с помощью CHost::NATEndpoint();
	- далее следует обычный процесс пинга.
+3. Реализовать подтверждение о получении пакета.
4. Рефакторинг
	- после загрузки host_map при стартапе проверять ендпоинт хоста, это может быть NAT endpoint(не будет совпадать ip) 
	- профайлер

google::protobuf::RepeatedPtrField<data::Table> results = *packet->mutable_job()->mutable_results();

	