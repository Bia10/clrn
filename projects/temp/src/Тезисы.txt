частью механизма сканирования уязвимостей хоста является определение доступности хоста. 
доступность хоста определяется посредством пинга.
способ пинга настраивается пользователем, опции выполняемые во время пинга:
1. ICMP ping
2. TCP port ping, список портов задается пользователем
3. Resolve name

требования:
1. кол-во одновременно пингуемых узлов может быть велико(несколько подсетей) 
2. кол-во портов задается пользовтелем(теоретически может быть 65535)
3. пингер не должен съедать все время процессора
4. высокое быстродействие

из готовых решений напрашивается nmap, но он тяжеловат и на таких больших диапазонах хостов/портов непроизводителен.
для выполнения требований так же очевидно что все выполняемые операции должны бюыть асинхронны
целесообразно использовать единый пул потоков для выполнения множества асинхронных операций
выбрали boost.asio

Реализация пингера
Класс Pinger - описать задачи, что делает, зачем нужен
(создает операцию пинга, инициализирует, помещает новые запросы в очередь, управляет кол-вом потоков и кол-вом одновременно открытых сокетов, определяет доступность локальных портов)
Т.к. зависимость нагрузки процессора от кол-ва активных сокетов нелинейна, то приходится для контроля кол-ва одновременных операций коннекта использовать загрузку процессора. 
Т.о кол-во ожидающих сокетов, а значит и одновременно пингуемых портов, может доходить до нескольких тысяч.

Т.к. firwall'ом могут быть закрыты порты на машине выполнябщей пинг, необходим механизм определяющий доступность локальных портов.
Чтобы определить доступность порта пытаемся осуществиить коннект на невалидный адресс, если коннект удался - порт эмулирован файрволлом.
	typename PortState::Enum GetPortState(const Ports::value_type port)
	{
		boost::recursive_mutex::scoped_lock lock(m_PortsMutex);

		PortState::Enum& state = m_EnabledPorts[port];
		if (state == PortState::Unknown)
		{
			state = PortState::Pending;

			const std::size_t service = GetNextService();
			const SocketPtr socket(new TCPSocket(GetService(service)));
			const TimerPtr timer(new Timer(GetService(service)));

			socket->async_connect(
				Tcp::endpoint(Address(INVALID_IP), port),
				boost::bind(
					&PingerImpl::GetPortStateCallback, 
					this,
					ba::placeholders::error,
					port,
					socket,
					timer
				)
			);
			
			timer->expires_from_now(boost::posix_time::seconds(1));
			timer->async_wait(boost::bind(&PingerImpl::CancelConnect, this, socket));
		}

		return state;
	}

	void GetPortStateCallback(const boost::system::error_code& e, const Ports::value_type port, const SocketPtr, const TimerPtr)
	{
		boost::recursive_mutex::scoped_lock lock(m_PortsMutex);
		m_EnabledPorts[port] = e ? PortState::Enabled : PortState::Disabled;
	}

	void CancelConnect(const SocketPtr socket)
	{
		boost::system::error_code e;
		socket->close(e);
	}

В процессе пинга довольно часто приходится резолвить сетевое имя хоста, но к сожалению асинхронная версия getnameinfo отсутствует.
В бусте асинхронный резолвинг(resolver::async_resolve) имен проходит в фоновом потоке, который привязан к объекту io_service, 
т.о. используя один объект io_service получим всего одну одновременно активную операцию получения имени хоста. 
Чтобы повысить быстродействие кол-во объектов io_service равно числу потоков в пуле.

1. ICMP реализация пингера ICMP довольно проста, почти полностью повторяет предложенную в примерах boost::asio реализацию
http://www.boost.org/doc/libs/1_40_0/doc/html/boost_asio/example/icmp/ping.cpp
код достаточно прост, не требует особых пояснений.

2. TCP ping
TCP ping представляет собой попытку TCP коннекта по тестируемому порту, если попытка коннекта хотя бы на один порт удаленного узла успешна - узел считается доступным.
способы передачи результата пинга:
1. коллбэк, переданный в конструктор вызывается в момент выполнения всех задач пингера, 
2. во все асинхронные операции передается shared_ptr на экземпляр пинга, таким образом пока существует хотя бы одна операция - существует объект пинга, 
при неудачном пинге, после того, как завершаться все асинхронные операции в деструкторе вызывается коллбэк с полученными в ходе пинга данными.

код запускающий асинхронный коннект:
		void PingPort(const Ports::value_type port)
		{
			const Tcp::endpoint ep(m_Address, port);
			const SocketPtr socket(new TCPSocket(m_Owner.GetService(m_ServiceIndex)));
			m_Sockets.push_back(socket);

			m_Owner.OnSocketCreated(); 
			
			socket->async_connect(ep, boost::bind(
				&Ping::TCPConnectCallback, 
				shared_from_this(), 
				boost::asio::placeholders::error, 
				socket
			));
		}
коллбэк:
		void TCPConnectCallback(const boost::system::error_code& e, const SocketPtr socket)
		{
			m_Owner.OnSocketClosed();

			if (!e)
				TCPPingSucceeded(socket);
			else
				TCPPingFailed(socket);
		}
соответсвующие обработчики:
		void TCPPingSucceeded(const SocketPtr socket)
		{
			const boost::posix_time::time_duration td(boost::posix_time::microsec_clock::local_time() - m_StartTime);

			boost::system::error_code error;
			socket->shutdown(TCPSocket::shutdown_both, error);

			// pinged successfully, close all opened sockets
			boost::mutex::scoped_lock lock(m_DataMutex);
			CloseSockets();

			PingerLogic::OnTcpSucceeded(static_cast<std::size_t>(td.total_milliseconds()));
		}

		void TCPPingFailed(const SocketPtr socket)
		{
			// ping on this port fails, close this socket
			boost::system::error_code error;
			socket->close(error);

			boost::mutex::scoped_lock lock(m_DataMutex);
			const std::vector<SocketPtr>::const_iterator it = std::remove(
				m_Sockets.begin(), 
				m_Sockets.end(),
				socket
			);

			m_Sockets.erase(it, m_Sockets.end());

			if (m_Sockets.empty())
				m_PingTimer.cancel(); // all ports failed, cancel timer
		}

3. Name resolving
бустовый резолвер в зависимости от типа переданного агрумента выполняет:
gethostnameinfo или ....

		virtual void StartResolveNameByIp(unsigned long ip) override
		{
			const Tcp::endpoint ep(Address(ip), 0);

			m_Resolver.async_resolve(ep, boost::bind(
				&Ping::ResolveFQDNCallback, 
				shared_from_this(),
				boost::asio::placeholders::error,
				boost::asio::placeholders::iterator
			));
		}
		
		virtual void StartGetNetBiosName(const std::string& name) override
		{
			m_Resolver.async_resolve
			(
				Tcp::resolver::query(Tcp::v4(), name, ""), 
				boost::bind
				(
					&Ping::ResolveNetBiosCallback, 
					shared_from_this(),
					boost::asio::placeholders::error,
					boost::asio::placeholders::iterator,
					name
				)
			);
		}
		
		void ResolveFQDNCallback(const boost::system::error_code& e, const Tcp::resolver::iterator it)
		{
			if (e)
				PingerLogic::OnFqdnFailed();
			else
				PingerLogic::OnFqdnResolved(it->host_name());
		}

		void ResolveNetBiosCallback(const boost::system::error_code& e, const Tcp::resolver::iterator it, const std::string& name)
		{
			if (e || it->endpoint().address() != m_Address)
				PingerLogic::OnNetBiosFailed();
			else			
				PingerLogic::OnNetBiosResolved(name);
		}
		
4. Логика пингера
Логика пингера вынесена в отдельную абстракцию по нескольким причинам:
1. Разделение операций с сокетами и бизнесс-логики пингера
2. Возможность в будущем использования нескольких стратегий в ходе работы пингера
3. Возможность покрытия юнит-тестами логики как отдельной сущности

class Ping : public boost::enable_shared_from_this<Ping>, public PingerLogic

Детально логику описывать не буду, приведу примеры кода, говорящие сами за себя.
	//! On ping start
	void OnStart()
	{
		InitPorts(m_Request.m_Ports);

		const bool ipResolved = ResolveIP(m_Request.m_HostName);

		if (!ipResolved)	
			StartResolveIpByName(m_Request.m_HostName);
	}

	//! On ip resolved
	void OnIpResolved(const unsigned long ip)
	{
		boost::recursive_mutex::scoped_lock lock(m_Mutex);
		m_Result.m_ResolvedIP = ip;	

		if (m_Request.m_Flags & SCANMGR_PING_RESOLVE_HOSTNAME)
		{
			m_HasPendingResolve = true;
			StartResolveNameByIp(ip);
		}

		if (m_Request.m_Flags & SCANMGR_PING_ICMP)
		{
			// if tcp ping needed it will be invoked after icmp completes
			StartICMPPing(m_Request.m_TimeoutSec);
			return;
		}

		if (m_Request.m_Flags & SCANMGR_PING_TCP)
		{
			// in case of tcp ping only
			StartTCPPing(m_Request.m_TimeoutSec);
		}
	}
коллбэки, переопределяемые в классе Ping:
private:

	//! Init ports
	virtual void InitPorts(const std::string& ports) = 0;

	//! Resolve ip
	virtual bool ResolveIP(const std::string& name) = 0;

	//! Start resolve callback
	virtual void StartResolveNameByIp(unsigned long ip) = 0;

	//! Start resolve callback
	virtual void StartResolveIpByName(const std::string& name) = 0;

	//! Start TCP ping callback
	virtual void StartTCPPing(std::size_t timeout) = 0;

	//! Start ICMP ping 
	virtual void StartICMPPing(std::size_t timeout) = 0;

	//! Start get NetBios name
	virtual void StartGetNetBiosName(const std::string& name) = 0;

	//! Cancel all pending operations
	virtual void Cancel() = 0;

Покрытие юнит-тестами




